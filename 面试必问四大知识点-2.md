

# Redis

### 5种数据类型

> 1. String
> 2. List
> 3. Set
> 4. Zset
> 5. Hash

### 为什么要使用redies

> nosql,单线程,在内存中,读写快,广泛用于缓存,分布式锁

主要从**高性能	和	高并发**

#### 高性能

如果直接访问数据库,会进行慢操作,等待时间较长,如果我们将数据缓存在redis中一份,当再次访问的时候这些数据可以直接从缓存中读取,而且速度很快.

#### 高并发

直接操作缓存能够承受的请求是远远大于直接访问数据库的,所以考虑将部分数据转移到缓存中

#### 为什么要用 redis 而不用 map/guava 做缓存?

缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

### redis线程模型

redis内部是使用的文件事件处理器,file event handler这个文件时间处理器是单线程的,所以redis也是单线程,它采用IO多路复用机制同时监听多个socket,

1. 多个socket
2. IO多路复用程序
3. 文件事件分派器
4. 事件处理器

### redis删除

采用定期删除+惰性删除

定期删除:	每隔100ms随机抽取一些设置了过期时间的key检查是否过期,如果过期就删除.

惰性删除:	直到你下次使用这个key才会检查他是否过期

#### redis内存淘汰机制

redis 提供 6种数据淘汰策略：

1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

### redis 持久化机制

#### RDB 快照持久化

某个时间点,创建一个快照,此快照包含有redis拥有的所有数据,子进程将快照中的全部数据写成一个副本文件,然后替换.可以复制到其他服务器创建具有相同数据的服务器.留在本地,在下次重启时,加载数据

#### AOF

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

#### **补充内容：AOF 重写**

AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。

AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。

在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作

### redis事务

redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚

### redis缓存雪崩

缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

- 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
- 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
- 事后：利用 redis 持久化机制保存的数据尽快恢复缓存![image-20191212161039442]($%7Bpic%7D/image-20191212161039442.png)

### redis缓存穿透

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

> 解决1: **缓存无效 key** : 如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间
>
> 解决2:**判断 key 是否合法**,把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

![image-20191212161704622]($%7Bpic%7D/image-20191212161704622.png)

### 如何解决redis并发竞争key问题

多个系统同时对一个key进行操作,最后的执行的顺序和我们期望的顺序不同,也就可能导致不同的结果

> 分布式锁:zookeeper或者redis
>
> zk:文件树结构,临时有序节点可以实现分布式锁

大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。

### 数据一致性问题

一般来说,缓存中的数据和数据库中的数据不一定必须完全一致,只需要保证最终一致性即可









# MySql优化

