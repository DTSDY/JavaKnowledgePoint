# JVM

## java内存区域

运行时数据区域：

![image-20191211145328012]($%7Bpic%7D/image-20191211145328012.png)

jdk1.8

![image-20191211145358954]($%7Bpic%7D/image-20191211145358954.png)

线程私有的:程序计数器，虚拟机栈，本地方法栈

线程共享的;堆，方法区，直接内存

2.1 程序计数器

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

唯一一个不出现OOM的内存区域，整形

2.2 java虚拟机栈

存放 栈帧 包含局部变量表主要存放了编译器可知的各种数据类型，对象引用

会出现两种错误

1. **StackOverFlowError：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度

2. **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展

每次函数调用结束后都会有一个栈帧被弹出，1、return 2、抛出异常



2.3 本地方法栈

为虚拟机使用到的native方法服务，即C++或C语言



2.4 堆

虚拟机中最大的一块，是所有线程所共享的。这是也是GC的主要区域。

jdk 7之前有三部分1、新生代	2、老年代	3、永久代

jdk 8之后只有 新生代 和 老年代



新生代之后 可以分为 Eden区,from,to

对象首先在Eden区域内分配，在新生代垃圾回收之后，如果对象还存活，则进入s0或s1,并且对象年龄增加1

当年龄增加到一定程度（默认为15）,就会晋升到老年代中



> "Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。

堆中最容易发生OOM,

1. OOM.GC 多次GC操作却只回收到很少的空间时
2. java.long.OOM 创建新的对象时,堆内存中的空间不足以存放新创建的对象(和本机物理内存大小无关,和你配置的堆内存大小有关)



2.5 方法区

永久代 永久代是hotspot的概念 方法区是java虚拟区的规范中定义,是一种规范,而永久代是一种实现,

垃圾收集基本不出现在此区域,但是数据并非永久存在

1.8之后称为 元空间 使用的直接内存,如果不指定大小,随着更多的类的创建,虚拟机会耗尽所有可用的系统内存



2.6 运行时常量池

是方法区中的一部分,1.7之后从常量池中从方法区中移了出来,在java堆中开辟了一块区域存放运行时常量池



2.7 直接内存

既不是虚拟机运行时数据区的一部分,也不是虚拟机规范中定义的内存区域,但也被频繁使用,而且也会发生OOM



## hotspot虚拟对象

3.1 对象的创建

过程:类加载检查----2.分配内存----3.初始化零值----4.设置对象头----5.执行init方法

1. 类加载检查:检查这个指令的参数是否能在常量池中定位到这个类的符号引用,并检查是否已经被加载过,解析和初始化过.如果没有则执行相应的类加载过程

2. 分配内存:通过类加载检查之后,虚拟机为新生对象分配内存.分配的方式有"指针碰撞"和"空闲列表"两种,取决于java堆是否规整,而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定.

    取决于GC收集器的算法是"标记-清除",还是"标记-整理",复制算法也是规整的

    1. 指针分配

        原理:用过的全部整合到一边,没有用过的内存放在另一边,中间有一个分界值指针,只需要向着没用过的内存方向将该指针移动对象内存大小位置即可

        Serial,ParNew

    2. 空闲列表

        原理:虚拟机会维护一个列表,该列表会记录那些内存块是可用的,在分配时找一块足够大的内存块划分给对象实例,最后更新列表记录

        CMS

    内存分配并发问题:

    1. CAS+失败重试:每次不加锁而是假设没有冲突二区完成某项操作,如果因为冲突失败就重试,直到成功为止.保证了更新操作的原子性
    2. TLAB:为每一个线程在Eden区分配一块内存,JVM在给线程中的对象分配内存时,首先在TLAB中分配,当对象大于TLAB中的剩余内存或者TLAB的内存已用尽时,再采用上述的CAS进行内存分配.

3. 初始化零值:内存分配完成后,虚拟机将分配到的内存空间都初始化为零值,程序可以访问到这些数据类型对应的零值.

4. 设置对象头:虚拟机要对对象进行必要的设置,即对象中的各种信息设置到对象头中

5. 执行init方法:一个新的对象已经产生,但是并没有将程序员设定的初始值赋给对象,只有执行了init方法之后,才是我们所需要的对象



3.2 对象的内存布局

对象头,实例数据和对齐填充

对象头包括两部分信息:

> 1. 用于存储对象自身的自身运行时数据
> 2. 类型指针:虚拟机通过此来确定这个对象是哪个类的实例

实例数据部分是对象真正的存储的有效信息

对齐填充部分没有特别意义,不必须存在,仅仅占位



3.3 对象的访问定位

建立对象就是为了使用对象,对象的访问方式由虚拟机实现而定,目前主流的访问方式为使用句柄和直接指针

> ![image-20191212092750657]($%7Bpic%7D/image-20191212092750657.png)
>
> ![image-20191212092803800]($%7Bpic%7D/image-20191212092803800.png)

句柄:存储有稳定的句柄地址,对象被移动时,只会改变实例数据指针,而本身不需要更改.

直接指针:最大的好处就是速度快,节省了一次指针定位的时间开销



## 补充

```java
String str1 = "abcd";
//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str2 = new String("abcd");//堆中创建一个新的对象
```

![image-20191212093148284]($%7Bpic%7D/image-20191212093148284.png)

图片来源：https://www.journaldev.com/797/what-is-java-string-pool

**只要使用 new 方法，便需要创建新的对象。**



## JAVA垃圾回收

## 堆内存中对象的分配与回收

主要对新生代 和老年代进行垃圾回收

新生代中还有 Eden from to区

接上 首先分配在Eden 发生GC 存活的对象会进入 To ,经过多次后 年龄到一定程度,晋升老年代之后

经过GC之后,Eden 和 FROM 区被清空,这时From 和 To 会交换角色,无论如何保证To区为空.直到To区被填满之后,会把所有对象移动到老年代之中



1.1 大多数情况下,对象在新生代中eden区分配.当没有足够的空间分配时,虚拟机将发生一次Minor GC

- **新生代 GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。
- **老年代 GC（Major GC/Full GC）**:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上

1.2 大对象直接进入老年代

大对象就是需要连续内存空间的对象

1.3 长期存活的对象进入老年代

1.4 动态对象年龄判定

空间中相同年龄所有对象大小的总和大于空间的一半,大于该年龄的对象就可以直接进入老年代,无需达到要求的年龄

## 如何判断对象死亡

> 1. 引用计数法
> 2. 可达性分析算法

1. 给对象添加一个引用计数器,当有一个地方引用时,计数器就加一.如果为0,则没有被引用,就是垃圾

    问题:无法解决循环引用

2. 可达性分析算法:判断引用的所有节点 如果无法到到达GC Roots,如果没有任何引用链相连的话,则证明此对象是不可用的

### 四个引用

> 强引用:直接引用
>
> 软引用:可有可无的生活用品,实现内存敏感的高速缓存
>
> 弱引用:弱引用对象相比于软引用 拥有更短的生命周期,只要发现有弱因语言,就会被回收
>
> 虚引用:等于没有任何应用,随时都能被回收

虚应用对象主要用来跟踪对象被垃圾回收的活动

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

2.4 不可达对象 至少经过2次标记过程才会真正被清除

2.5 如何判断一个常量是废弃常量

没有String对象引用,1.7之后运行时常量池已经从方法区中移了出来

2.6 如何判断一个类无用

类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

可以被回收,但是并不必须



### 垃圾收集算法

标记清除:	首先标记需要清除的对象,在标记完成后统一回收所有被标记的对象.会带来两个问题1.效率问题2.空间问题(标记清除后产生大量不连续的碎片)

复制算法:	将内存分为大小相同的两块,每次使用其中的一块,一块使用完之后将还存活的对象复制到另一块中,一次性将空间清理掉

标记整理:	先标记但是不清楚,而是让所有可存活对象向一端移动,直接清理掉边界之外的内存

分代收集:	根据对象的存活周期分成不同几块,为每个区域悬着不同的算法.

比如新生代中,每次都有大量对象死去,则选择复制算法,而老年代存活率较高,而且没有额外空间对它进行担保,所以我们选择标记清除,或者标记整理.

### 垃圾收集器

5种

> Serial,ParNew,Parallel Scavenge,CMS,G1

Serial: 串行,单线程,除GC外其他都停止.**新生代采用复制算法，老年代采用标记-整理算法。**

ParNew:多线程版本,除GC外其他也都停止,采用多线程执行

Parallel Scavenge:吞吐量(高效率的利用Cpu)  运行用户代码的时间与CPU总消耗时间的比值

CMS:减少等待时间,提高用户体验

G1:面向服务器的垃圾收集器

## 类加载过程

加载----连接(验证---准备----解析)----初始化

加载:

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

验证:	文件格式验证,元数据验证,字节码验证,符号引用验证

准备:	为类变量分配内存并设置类变量初始值的阶段

并不包括实例变量

解析:	将常量池内的符号引用替换为直接引用的过程.也就是得到类或者字段,方法在内存中的指针或者偏移量

初始化:	真正执行类中定义的Java程序代码,初始化是执行类构造器clinit方法的过程

### 类加载器

JVM中有三个重要的ClassLoader

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3. **AppClassLoader(应用程序类加载器)** :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

### 双亲委派

在类加载时,首先判断当前类是否被加载过,已经被类加载的类直接返回,否则才会尝试加载.加载的时候首先会把该请求委派该父类加载器的loadClass()处理,因为所有的请求最终都应该传送到顶层的启动类加载器中.当父类加载器无法处理时,才由自己来处理.当父类加载器为null时,会使用启动类加载器BootstrapClassLoader作为父类加载器



> 其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。官方API文档对这部分的描述如下:

好处:

> 保证了Java程序的稳定运行,可以避免类的重复加载,保证了Java核心API不被篡改

如果不想使用双亲委派,可以自定义一个类加载器,然后重写loadClass()



6: 1 :1

# 多线程

### 线程和进程

进程:	程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。

线程:	比进程更小的执行单位,一个进程在执行过程中可以产生多个线程,多个线程贡献进程的堆和方法区资源.但是每个线程有自己的程序计数器,虚拟机栈和本地方法栈

> 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反

程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

- **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

### 多线程可能带来什么问题?

内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。

### 线程的生命周期

线程创建之后它将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。线程在执行 Runnable 的`run()`方法之后将会进入到 **TERMINATED（终止）** 状态。

### 什么是上下文切换

当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。

### 死锁

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

> 构成死锁的四个条件:
>
> 1. 互斥条件：该资源任意一个时刻只由一个线程占用。
> 2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
> 3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
> 4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

解决方法,破坏四个条件

#### sleep 和 wait 方法的区别

- 两者最主要的区别在于：**sleep 方法没有释放锁，而 wait 方法释放了锁** 。
- 两者都可以暂停线程的执行。
- Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。

#### 直接调用run方法是不是多线程

接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**

### synchronize关键字

解决多个线程之间访问资源的同步性,保证被他修饰的方法或者代码块在任意时间内都只能有一个线程执行.

属于重量级锁,效率低下1.6之后进行了优化

修饰实例方法(给对象实例上锁),修饰静态方法,修饰代码块

### 双重检验锁实现对象单例

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

底层是由JVM实现的

### synchronized和ReentrantLock 的区别

> **两者都是可重入锁**
>
> **ReentrantLock 比 synchronized 增加了一些高级功能**
>
> > **①等待可中断；**
> >
> > **②可实现公平锁；**
> >
> > **③可实现选择性通知（锁可以绑定多个条件）**

### volatile关键字

1. 可见性
2. 指令重排序

### ThreadLocal

> `ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。

每个类独有的变量其实是一个Map只是一种引用,映射关系.

### ThreadLocal 内存泄露问题

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用,而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，`ThreadLocalMap` 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。使用完 `ThreadLocal`方法后 最好手动调用`remove()`方法

### 线程池

**使用线程池的好处**：

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 如何创建线程池

使用ThreadPoolExecutor 7个参数,最后一个参数有四个种类

ThreadPoolExecutor的七个参数:

corePoolSize 核心线程数

MaxPS  最大线程数

keepAliveTime  存活时间

TimeUnit  时间单位

BlockingQueue  任务队列

ThreadFactory  线程工厂

RejectStrategy  拒绝策略

> Abort    抛异常
>
> Discard 悄悄扔掉
>
> DiscardOld 扔掉最先的任务
>
> CallerRuns 谁提交任务谁来执行

![image-20191212113241473]($%7Bpic%7D/image-20191212113241473.png)

## JUC

最安全的类 unsafe类

### Atomic 原子类

**基本类型**

使用原子的方式更新基本类型

- AtomicInteger：整形原子类
- AtomicLong：长整型原子类
- AtomicBoolean：布尔型原子类

**数组类型**

使用原子的方式更新数组里的某个元素

- AtomicIntegerArray：整形数组原子类
- AtomicLongArray：长整形数组原子类
- AtomicReferenceArray：引用类型数组原子类

**引用类型**

- AtomicReference：引用类型原子类
- AtomicStampedReference：原子更新引用类型里的字段原子类
- AtomicMarkableReference ：原子更新带有标记位的引用类型

**对象的属性修改类型**

- AtomicIntegerFieldUpdater：原子更新整形字段的更新器
- AtomicLongFieldUpdater：原子更新长整形字段的更新器
- AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

**主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作****

### AQS的全称为（AbstractQueuedSynchronizer）

>  AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。

#### AQS 原理概览

**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。

### AQS 组件总结

- **Semaphore(信号量)-允许多个线程同时访问：** synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
- **CountDownLatch （倒计时器）：** CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
- **CyclicBarrier(循环栅栏)：** CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。

### ConcurrentHashMap

ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。

- **底层数据结构：** JDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
- **实现线程安全的方式（重要）：** ① **在JDK1.7的时候，ConcurrentHashMap（分段锁）** 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 **到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）** 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **Hashtable(同一把锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

**跳表**   **跳表是一种利用空间换时间的算法。**

![image-20191212114957550]($%7Bpic%7D/image-20191212114957550.png)



### 使用线程池的好处

> 1. 降低资源消耗
> 2. 提高响应速度
> 3. 提高线程的可管理性

### ThreadPoolExecutor

### 线程池线程数量

**如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。**

**但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。**

有一个简单并且适用面比较广的公式：

- **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

### 乐观锁与悲观锁

#### 乐观锁

每次都觉得不会有人修改数据,所以不加锁,但是操作之前都会看一下是否有人改变了,利用版本号和CAS

> 适合于 读多写少,即使冲突较少发生,减少开锁,上锁的消耗

#### 悲观锁

每次都觉得有人要修改,所以加锁,保证同时只能有一个线程拿到对象,只有拿到锁之后才能进行修改

> 如果写多的话,不拿锁一直会产生冲突,反而会降低了性能

#### 乐观锁实现的两种方法

1. 版本号机制:

    添加一列,为版本号,每次修改版本加1 ,每次验证是否为读取到数据是的版本

2. CAS算法:0.

    比较与交换,无锁算法.在不使用所的情况下实现多线程之间的变量同步,也就是在没有线程被阻塞的情况下实现变量的同步,所以也叫非阻塞同步.

    需要读写的值V	进行比较的值A	拟写入的新值B

    当 V=A是才通过原子方式来更新V的值 否则不会执行任何操作,一般情况下会进行自旋不断的进行尝试

#### 乐观锁的缺点

ABA:	

> 如果初次读取时A值,再次检测时,还是A值能说他没有被修改过吗,也有可能修改为其他值之后又修改成了A值,所以会被误认为是没有进行过修改\

循环时间开销过大:	

>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 

只能保证一个共享变量的原子操作:

> CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。

### JUC中原子类

**基本类型**

使用原子的方式更新基本类型

- AtomicInteger：整型原子类
- AtomicLong：长整型原子类
- AtomicBoolean ：布尔型原子类

**数组类型**

使用原子的方式更新数组里的某个元素

- AtomicIntegerArray：整型数组原子类
- AtomicLongArray：长整型数组原子类
- AtomicReferenceArray ：引用类型数组原子类

**引用类型**

- AtomicReference：引用类型原子类
- AtomicReferenceFieldUpdater：原子更新引用类型里的字段
- AtomicMarkableReference ：原子更新带有标记位的引用类型

**对象的属性修改类型**

- AtomicIntegerFieldUpdater:原子更新整型字段的更新器
- AtomicLongFieldUpdater：原子更新长整型字段的更新器
- AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。
- AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

